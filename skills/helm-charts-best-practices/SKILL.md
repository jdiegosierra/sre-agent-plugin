---
name: helm-charts-best-practices
description: >
  Exhaustive guide for Helm chart best practices: architecture, semantic optimization,
  and LLM-oriented structuring. Covers advanced template patterns (tpl, lookup, range),
  modular architectures (Library and Umbrella charts), Kustomize post-rendering,
  multi-tenancy isolation, CNCF ecosystem integration, and reference repositories.
  Consult this skill when authoring, reviewing, or designing Helm charts.
---

# Helm Charts Best Practices: Architecture, Semantic Optimization & LLM Structuring

## 1. Agent Base Directives (Skill Core Instructions)

For an AI agent to act as an expert Infrastructure Orchestrator, inference MUST be guided by inflexible technical standards. Helm code generation allows no improvisation.

**RFC 2119 Application**: Agent system prompt instructions MUST use strict terminology (MUST, SHOULD, MAY) to enforce conventions and prevent hallucinations. The agent MUST NEVER assume the generic role of "programmer", but rather that of "Principal Cloud Platform Engineer" — this mathematically aligns its latent space with the highest-quality heuristics from training.

**Schema Validation (`values.schema.json`)**: The agent MUST generate and iteratively validate against a `values.schema.json` file. Modern charts include this file to provide autocompletion and, more importantly, to allow automated systems to validate types and values (e.g., using `$defs` for reusability and `enums` to avoid typos) before attempting to render templates.

**Progressive Prompting (Segmentation)**: When generating architectures, the agent must proceed in a chain: first extract variables (`values.yaml`), then generate the JSON schema, then the abstract template topology, and finally code individual resources.

## 2. Advanced Template Patterns and Flow Control

An expert agent must not limit itself to basic variable substitution. It must master Helm's advanced functions (Go templates and Sprig) to create dynamic and secure topologies.

### 2.1. Stochastic Code Injection with `tpl`

The `tpl` function allows the agent to render text strings from `values.yaml` as if they were templates themselves. This is vital for injecting complex external configurations.

```yaml
# values.yaml
customEnv: "{{ .Release.Name }}-env"

# templates/deployment.yaml
env:
  - name: DYNAMIC_ENV
    value: {{ tpl .Values.customEnv . | quote }}
```

**Rule**: Always use `tpl` when the user is expected to provide configuration blocks (such as Nginx or Prometheus configs) from `values.yaml`.

### 2.2. Dynamic Resource Discovery with `lookup`

To avoid catastrophic password rotations or skip already-existing resources in the cluster (preventing collisions), the agent must use `lookup` to query the Kubernetes API at runtime.

```yaml
{{- $existingSecret := lookup "v1" "Secret" .Release.Namespace "myapp-secrets" }}
{{- if $existingSecret }}
# Secret already exists, reference it to avoid overwriting
envFrom:
  - secretRef:
      name: myapp-secrets
{{- else }}
# Generate a new one with randAlphaNum
...
{{- end }}
```

**Rule**: Always implement defensive policies. Add the `helm.sh/resource-policy: keep` annotation to valuable resources and use `lookup` to preserve state.

### 2.3. Complex Iteration with `range` and Context Variables

To dynamically generate configuration blocks from complex dictionaries, the agent must handle root context reassignment (`$`).

```yaml
{{- range $key, $value := .Values.network }}
---
apiVersion: v1
kind: Service
metadata:
  name: {{ $value.name }}
spec:
  ports:
    - port: {{ $value.port }}
      targetPort: {{ $value.targetPort }}
{{- end }}
```

**Rule**: When using `range`, the `.` context changes to the iterated element. If `.Release.Name` is needed inside the loop, the agent must assign the root context to a prior variable (`{{- $root := . -}}`).

## 3. Modular Architectures: Open Source Case Studies

Enterprise-grade infrastructure does not deploy monoliths; it composes complex architectures. The agent must replicate the two most mature industry patterns.

### 3.1. Library Chart Pattern (Case Study: Bitnami)

Library Charts do not deploy resources of their own (`type: library` in `Chart.yaml`); they package reusable logic (`_helpers.tpl`) to keep code DRY (Don't Repeat Yourself).

**Industry Analysis (Bitnami common chart)**: Bitnami uses its `common` chart as a base abstraction for hundreds of applications. It encapsulates complex functions for validation, affinity generation, and unified naming.

Example of a complex helper generated by the agent (Bitnami-inspired):

```yaml
{{/* Define pod affinities based on configuration */}}
{{- define "common.affinities.pods.soft" -}}
podAntiAffinity:
  preferredDuringSchedulingIgnoredDuringExecution:
    - weight: 100
      podAffinityTerm:
        labelSelector:
          matchLabels:
            app.kubernetes.io/component: {{ .component }}
        topologyKey: kubernetes.io/hostname
{{- end -}}
```

**Rule**: When designing a suite of multiple microservices, the agent must segregate all common label, toleration, and resource logic into a nested or referenced library-type chart.

### 3.2. Umbrella Chart Pattern (Case Study: Prometheus-Community)

An Umbrella Chart manages an ecosystem by delegating to subcharts (e.g., microservices, databases) nested in the `charts/` directory or managed via `dependencies` in `Chart.yaml`.

**Industry Analysis (Kube-Prometheus-Stack)**: The Prometheus community chart includes multiple dependencies (alertmanager, grafana, kube-state-metrics).

```yaml
# Chart.yaml
dependencies:
  - name: alertmanager
    version: "0.22.x"
    repository: "https://prometheus-community.github.io/helm-charts"
    condition: alertmanager.enabled
```

**Rule**: The agent MUST use the dependency conditional (`condition: depName.enabled`) to allow operators to disable entire architecture modules. Additionally, global values shared between the Umbrella Chart and subcharts must be injected via the magic `global:` key in `values.yaml`.

## 4. Post-Rendering Injection Patterns (Kustomize)

Maintainers often face the anti-pattern of adding hundreds of conditional flags in `values.yaml` (e.g., `if .Values.injectSidecar`). For complex implementations, the industry relies on the Post-Rendering paradigm.

Helm v3 introduced the ability to pass rendered manifests through an external manipulation binary (commonly Kustomize) before sending them to the Kubernetes API.

**Tactical Example (Multi-Environment Security Sidecar Injection)**:

The agent does not need to alter the source chart. It generates a `post-renderer.sh` script and a Kustomize structure:

```bash
#!/bin/bash
cat <&0 > all-helm-output.yaml
kustomize build .
```

```yaml
# kustomization.yaml
resources:
  - all-helm-output.yaml
patches:
  - path: add-sidecar.yaml
    target:
      kind: Deployment
      name: my-application
```

**Rule**: If the user requests mutating a third-party Open Source chart to add corporate proxies (Istio, Linkerd) or log agents (Fluentbit) without forking the repository, the agent MUST propose and write a deployment flow based on `helm install --post-renderer` with a Kustomize overlay.

## 5. Isolation and Multi-Tenancy (Hard Security)

When the agent designs infrastructures to host multiple clients (Multi-Tenancy), Kubernetes default security is unacceptable. "Hard Multi-Tenancy" MUST be applied.

The agent must emit a central "Tenant" Helm Chart (Tenant Template) that orchestrates containment. This chart does not deploy applications — it deploys boundaries:

- **Network Isolation (NetworkPolicy)**: Default-deny for all ingress and egress traffic, explicitly allowing only internal namespace traffic and cluster DNS requests.
- **Resource Protection (ResourceQuota and LimitRange)**: Prevention of the "noisy neighbor" problem.
- **Access Isolation (RBAC)**: Dedicated ServiceAccounts, namespace-confined Roles, strictly prohibiting `ClusterRoleBinding` usage.

Tenant Chart structure generated by the agent:

```yaml
# templates/networkpolicy.yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: {{ .Release.Name }}-default-deny
spec:
  podSelector: {} # Selects all pods
  policyTypes:
  - Ingress
  - Egress
  # Block everything except DNS
  egress:
  - ports:
    - port: 53
      protocol: UDP
    - port: 53
      protocol: TCP
```

## 6. CNCF Ecosystem Integration (Artifact Hub & OCI Security)

For a chart to be recognized as "Enterprise-Grade" by automated audits and corporate RAG systems, the agent must generate native integration metadata.

**Artifact Hub Annotations**: The agent must include classification metadata within `Chart.yaml` using the `artifacthub.io/` prefix to facilitate semantic indexing.

**OCI Registries**: Helm v3 supports pushing charts to container registries (OCI). The agent must write CI/CD pipelines and commands assuming `oci://` protocol usage (e.g., `helm push mychart-1.0.0.tgz oci://ghcr.io/namespace`).

**Cryptographic Signatures**: Every integration pipeline generated by the agent for production environments must include `helm package --sign` (with PGP or sigstore) and require `helm install --verify`.

## 7. Reference Repositories for Agent Ingestion

To calibrate the base model and feed the Skill context (via internal RAG or direct Few-Shot Prompting), the agent MUST be configured to analyze the architectural structure of the following Open Source repositories. These projects represent the gold standard in the community and solve the most complex edge cases in the industry:

### Bitnami Common Library (`bitnami/common`)

The absolute reference for understanding the Library Chart pattern. The agent must meticulously analyze the `templates/_helpers.tpl` and `templates/_labels.tpl` files from this repository to assimilate how reusable global Kubernetes logic is abstracted (e.g., functions for generating affinity rules, toleration injection, or unified configuration variable consolidation). Provides the best template for abstracting repetitive logic without instantiating components.

### Prometheus Community (`prometheus-community/helm-charts`)

Particularly the main `prometheus` or `kube-prometheus-stack` chart. The definitive case study for mastering the Umbrella Chart pattern. Instructs the agent on efficiently managing a deep tree of third-party dependencies (such as Alertmanager, kube-state-metrics, or dedicated exporters) dictated via the `dependencies` block in `Chart.yaml`, integrating boolean conditional flags and overriding subchart configurations from a unified umbrella.

### KubeRay and vLLM Helm Charts

Indispensable if the agent designs AI/ML-optimized infrastructure. These repositories demonstrate highly advanced techniques for the native AI ecosystem, instructing the agent on properly provisioning strict hardware requests and limits for AI processing units (requesting `nvidia.com/gpu` scaling), mounting Hugging Face repository secret caches, and dynamically managing pod lifecycle for serving large models without disruption.

### CNOE CAIPE (Community AI Platform Engineering)

A fundamental tactical repository if the Skill needs to generate workflows based on Multi-Agent Systems (MAS) for platform engineering. Expresses in real Helm code the cloud-native method for implementing roles, local persistence, and inter-agent connectivity for AI-powered development and DevOps tools operating as cooperative pods within the cluster.
